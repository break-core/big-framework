
--[[
	                                                                ,,╓╓╥╗╗@@@╣╢
	                                               ,²╓╓╥╗@@@╣╣╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒U
	                               ,,╓╓╥m╗@@@╣╢▒▒▒▒▒▒▒▒▒Ñ╜`         "╙╣▒▒▒▒▒▒▒▒╣
	               ,,╓╓╗╗╗@@╣╣╢▒▒▒▒▒▒╣╝╨╜╙"`║▒▒▒▒▒▒▒▒╢╜                `╣▒▒▒▒▒▒▒
	,╓╓╥╗@@@╣╢╢▒▒▒▒ÑÑ╝╝╨╜╨╝╝╣▒▒▒▒▒▒▒▒╢      ]▒▒▒▒▒▒▒╝         ,,         ╙▒▒▒▒▒▒
	║▒▒▒▒▒"`                  `╝▒▒▒▒▒▒       ▒▒▒▒▒▒╝      ,@▒▒▒▒▒╣╗     ╓╗╣▒▒▒▒▒[
	 ▒▒▒▒▒U                     └▒▒▒▒▒       ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒╢╗╣╣▒▒▒▒▒▒▒▒▒▒
	 ▒▒▒▒▒╣       ²╓╓╥╗╗╗╖       ]▒▒▒▒[      ]▒▒▒▒[      ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
	 ║▒▒▒▒▒       ▒▒▒▒▒▒▒▒╣      ]▒▒▒▒▒       ▒▒▒▒[      ║▒▒▒▒▒▒▒▒▒▒╢╢Ñ╝╨╜╙╙▒▒▒▒▒[
	 ]▒▒▒▒▒       ╢▒▒▒▒▒▒╢╜      ║▒▒▒▒▒       ╢▒▒▒[      ]▒▒▒▒▒[            ╢▒▒▒▒╢
	  ▒▒▒▒▒[      └╙"``         @▒▒▒▒▒▒[      ]▒▒▒╢       ▒▒▒▒▒╣            ║▒▒▒▒▒
	  ║▒▒▒▒╢                   ²╙╣▒▒▒▒▒▒       ▒▒▒▒       ║▒▒▒▒▒   ,²╓      ]▒▒▒▒▒U
	  ]▒▒▒▒▒                       ╣▒▒▒▒       ╢▒▒▒╣       ╢▒▒▒▒▒▒▒▒▒╜       ▒▒▒▒▒╣
	   ▒▒▒▒▒[      ]@╣╣▒▒▒▒╣╗       ▒▒▒▒[      ║▒▒▒▒╗       ╙╣▒▒▒▒▒Ñ`        ║▒▒▒▒▒
	   ╢▒▒▒▒╢       ▒▒▒▒▒▒▒▒▒U      ║▒▒▒╢      ]▒▒▒▒▒@                       ]▒▒▒▒▒
	   ║▒▒▒▒▒       ╣▒▒▒▒▒▒▒╢       ║▒▒▒▒       ▒▒▒▒▒▒╣╖               ,[     ▒▒▒▒▒[
	    ▒▒▒▒▒U      ║Ñ╝╨╜╙"²        ▒▒▒▒▒       ║▒▒▒▒▒▒▒▒@╖,        ,╥╣▒╢@@╣╣╢▒▒▒▒╢╢
	    ▒▒▒▒▒[                    ╓╢▒▒▒▒▒[      ]▒▒▒▒▒▒▒▒▒▒▒▒▒╢╢╢▒╢ÑÑ╝╝╜╙""`
	    ║▒▒▒▒▒                ,╓@╢▒▒▒▒▒▒▒▒@╣╣╢▒▒▒▒╢Ñ╝╝╨╜╙""`           ╓╗@@@╗╖
	    ]▒▒▒▒▒    ,,╓╓╗╗@@@╣▒▒▒▒▒▒╢ÑÑ╝╝╜╙"``        ,²╓  ╔@@@╣╣╢▒▒▒U ,╣▒Ñ╙"╙╢▒Ñ
	     ▒▒▒▒▒▒▒▒▒╢Ñ╝╝╨╜╙"``             ╥@@@╗    ]▒▒▒▒  ]▒▒╣"``     ]▒▒╗,
	     "``       ,╓╖╓,       ]▒▒▒╣     ]▒▒▒▒╖   ║▒▒▒▒[  ▒▒▒   ,,    ╙╣▒▒▒▒╣%╖
	            ,╣▒▒╢╣╣▒▒@     ╢▒▒╣▒╣     ▒▒╢╣▒╖  ▒▒[▒▒╢  ║▒▒▒▒▒▒▒r       `"╙╣▒▒╕
	            ╣▒╣    ╙╜`     ▒▒╢ ╣▒╣    ▒▒▒╙▒▒╕]▒▒ ║▒▒  ]▒▒[         ╓@     ▒▒╢
	           ║▒▒[       ,   ]▒▒[  ▒▒╣   ║▒▒ ╙▒▒@▒▒ ]▒▒L  ▒▒╢   ,,╓╓  ╣▒▒╣@╣▒▒╣
	           ]▒▒[  ]╢▒▒▒▒[  ║▒▒╣╣╣╢▒▒╣  ]▒▒[ ╙▒▒▒[  ▒▒╣  ╢▒▒▒▒▒▒▒╢Ñ~    "╙"`  		
	            ╢▒▒     ]▒▒╢  ╢▒▒╙"``╙▒▒@  ▒▒╢  ╙▒╢`  ╨╜╜  ``
	             ╣▒▒h╖╥@▒▒▒▒ j▒▒╣     ╙╜╙` `
	              `╙╝ÑÑ╝╙ "`
                                                       
    
	BIG Games rbx.lua Framework [2017] - [2023]
	Written by Preston - preston@biggames.io
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Signal
	===========
	
	Easier and more streamlined + automatic usage of BindableEvents & Bindablefuncs. Faster and easier syntax.
	Signals do not replicate (use _L.Network for that).

	Update 8/20/20: now hack proof ayy
		
	===========
		\\\ Substitute for BindableEvents:Fire
		Signal.Fire(
			signalName,				<--	|REQ|	Signal name (UID)																	
			...,					<-- 		Anything :)							
		)

		\\\ Substitute for BindableEvent.Event
		Signal.Fired(
			signalName,				<--	|REQ|	Signal name (UID)																	
			...,					<-- 		Anything :)							
		)

		\\\ Substitute for BindableFunction:Invoke
		Signal.Invoke(
			signalName,				<--	|REQ|	Signal name (UID)																	
			...,					<-- 		Anything :)							
		)

		\\\ Substitute for BindableFunction.Invoked
		Signal.Invoked(
			signalName,				<--	|REQ|	Signal name (UID)																	
			...,					<-- 		Anything :)							
		)

		\\\ Returns signal instance
		Signal.Get(
			signalName,				<--	|REQ|	Signal name (UID)																						
		)
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--------|       Top       |--------
local Signal = {}

--------|     Setting     |--------

--------|     Library     |--------
local _L; coroutine.wrap(function()  _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))  end)()

--------|    Reference    |--------
local isServer = _L.Services.RunService:IsServer()
local events = {}
local funcs = {}

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--- Assert functions (ensures Signal is used correctly)
local function assertTypeNumber(num)
	assert(typeof(num) == "number", "Expected a number")
end

local function assertTypeString(str)
	assert(typeof(str) == "string", "Expected a string")
end


--- Handle list of services that we're able to use
local services = { 
	game:GetService("ReplicatedFirst"), 
	game:GetService("ReplicatedStorage"), 
	game:GetService("Players") 
}
if isServer then
	table.insert(services, game:GetService("ServerScriptService"))
	table.insert(services, game:GetService("ServerStorage"))
end

--- Handle errors and warnings
local function handleErrorsAndWarnings(errMsg)
	local success, result = pcall(settings)
	if success then
		return nil
	else
		local callerScript = nil
		local success2, error2 = pcall(function()
			local scriptInstance = rawget(getfenv(5), "script")
			assert(typeof(scriptInstance) == "Instance")
			assert(scriptInstance:IsA("ModuleScript") or scriptInstance:IsA("Script") or scriptInstance:IsA("LocalScript"))

			local foundServiceAncestor = false
			for _, service in ipairs(services) do
				if service:IsAncestorOf(scriptInstance) then
					foundServiceAncestor = true
					break
				end
			end

			if foundServiceAncestor then
				return nil
			end

			callerScript = string.format("callerScript:badpath:'%s'", scriptInstance:GetFullName())
			return nil
		end)

		if not success2 and not callerScript then
			callerScript = string.format("callerScript:err:'%s'", tostring(error2))
		end

		if not callerScript then
			return true
		end

		local debugMessage = string.format("Debug|%s|%s '%s' [%s]: %s", "Signal", tostring(debug.info(2, "n")), callerScript, tostring(errMsg), tostring(debug.traceback()))
		if not pcall(_G.Blunder, Enum.MessageType.MessageWarning, debugMessage) then
			warn(debugMessage)
		end

		return false
	end
end


--- Fire
Signal.Fire = function(eventName, ...)

	--- Ensure integrity
	if not handleErrorsAndWarnings(eventName) then
		return
	end
	
	--- Variables
	assertTypeString(eventName)
	eventName = string.lower(eventName)

	--- Get/create event
	local event = GetEvent(eventName)

	--- Signal for visualization/tracking purposes on Debug (Client only) META AF BTW
	if not isServer and eventName ~= "core signal fired" then
		Signal.Fire("CORE Signal Fired", eventName)
	end

	--- Fire event w/ data
	event:Fire(...)
end


--- On Fire
Signal.Fired = function(eventName)

	--- Ensure integrity
	if not handleErrorsAndWarnings(eventName) then
		return Instance.new("BindableEvent").Event
	end

	--- Variables
	eventName = string.lower(eventName)

	--- Get/Create event
	assertTypeString(eventName)	
	local event = GetEvent(eventName)

	--
	return GetEvent(eventName).Event
end


--- Invoke
Signal.Invoke = function(funcName, ...)
	if not handleErrorsAndWarnings(funcName) then
	  return
	end
	assertTypeString(funcName)
	funcName = string.lower(funcName)
	if not isServer and funcName ~= "core signal fired" then
		Signal.Fire("CORE Signal Fired", funcName)
	end

	--
	return GetFunc(funcName):Invoke(...)
end


--- Invoked
Signal.Invoked = function(functionName)
	if not handleErrorsAndWarnings(functionName) then
		return Instance.new("BindableFunction")
	end
	assertTypeString(functionName)
	functionName = string.lower(functionName)

	--
	return GetFunc(functionName)
end

--- Get signal instance
Signal.Get = function(eventName)
	if not handleErrorsAndWarnings(eventName) then
		return Instance.new("BindableEvent")
	end
	--- Variables
	assertTypeString(eventName)
	eventName = string.lower(eventName)
	
	--
	return GetEvent(eventName)
end

--- Freeze Signal to prevent tampering
table.freeze(Signal)

--- If the environment is a client, add external modification detection
if game:GetService("RunService"):IsClient() then
	task.spawn(function(modifiedSignal)
		local clonedSignal = table.clone(modifiedSignal)
		setmetatable(clonedSignal, nil)
		--[[
		TODO: I cannot wrap my head around metatables, so I can't accurately comment this :(

		]]
		local function compareTables(table1, table2)
			if table1 ~= table2 then
				if typeof(table1) ~= "table" or typeof(table2) ~= "table" then
					return false
				end
				for key, value in next, table2 do
					if rawget(table1, key) ~= value then
						return false
					end
				end
			end
			return true
		end

		while compareTables(getmetatable(modifiedSignal), getmetatable(modifiedSignal) and table.clone(clonedSignal)) and compareTables(modifiedSignal, clonedSignal) do
			wait(math.random() * 15 + 1)
		end

		local errorMessage = "ExternalModification : Signal"
		if not pcall(_G.Blunder, Enum.MessageType.MessageWarning, errorMessage) then
			warn(errorMessage)
		end
	end, Signal)
end


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--- Get (or create) BindableEvent
function GetEvent(eventName)
	--- Variables
	assertTypeString(eventName)
	eventName = eventName:lower()
	local event = events[eventName]

	--- Check if event already exists
	if not event then
		--- Create event
		event = Instance.new("BindableEvent")
		events[eventName] = event
	end

	--
	return event
end

--- Get (or create) a BindableFunction
function GetFunc(funcName)
	--- Variables
	assertTypeString(funcName)
	funcName = funcName:lower()
	local func = funcs[funcName]

	--- Check if function already exists
	if not func then
		func = Instance.new("BindableFunction")
		func[funcName] = signalFunction
	end
	return func
end


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

return Signal


